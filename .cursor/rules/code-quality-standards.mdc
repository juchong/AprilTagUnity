---
alwaysApply: true
description: Code quality standards and best practices for the AprilTagUnity project
---

# Code Quality Standards

This rule establishes coding standards and best practices for the AprilTagUnity project.

## Coding Conventions

### C# Style Guidelines
- Use PascalCase for public fields, properties, and methods
- Use camelCase for private fields and local variables
- Use descriptive names that clearly indicate purpose
- Add XML documentation for public APIs

```csharp
public class AprilTagController : MonoBehaviour
{
    [Header("Public Configuration")]
    [SerializeField] private float tagSizeMeters = 0.08f;
    [SerializeField] private int decimation = 2;
    
    private TagDetector detector;
    private bool isInitialized;
    
    /// <summary>
    /// Gets the current detector instance for tag processing
    /// </summary>
    public TagDetector GetDetector() => detector;
}
```

### Unity-Specific Patterns
- Use `[SerializeField]` for inspector-exposed private fields
- Implement proper MonoBehaviour lifecycle methods
- Use `[Header]` and `[Tooltip]` attributes for better inspector organization
- Follow Unity's naming conventions for components

```csharp
[Header("Detection Settings")]
[Tooltip("Physical size of AprilTag markers in meters")]
[SerializeField] private float tagSizeMeters = 0.08f;

[Header("Performance")]
[Tooltip("Downscale factor for detection (higher = faster, less accurate)")]
[SerializeField] private int decimation = 2;
```

## Error Handling

### Robust Error Handling Patterns
```csharp
void ProcessDetection()
{
    try
    {
        if (!ValidatePrerequisites())
            return;
            
        var result = PerformDetection();
        HandleDetectionResult(result);
    }
    catch (System.Exception ex)
    {
        Debug.LogError($"Detection failed: {ex.Message}");
        HandleDetectionError(ex);
    }
}

bool ValidatePrerequisites()
{
    if (detector == null)
    {
        Debug.LogWarning("Detector not initialized");
        return false;
    }
    
    if (webCamTexture == null || !webCamTexture.isPlaying)
    {
        Debug.LogWarning("Camera feed not available");
        return false;
    }
    
    return true;
}
```

### Null Safety
```csharp
// Always check for null before accessing
if (webCamTexture?.isPlaying == true)
{
    // Safe to proceed
}

// Use null-conditional operators
var textureWidth = webCamTexture?.width ?? 0;
var textureHeight = webCamTexture?.height ?? 0;
```

## Memory and Performance

### Disposal Pattern
```csharp
public class AprilTagController : MonoBehaviour, System.IDisposable
{
    private bool disposed = false;
    
    void OnDestroy()
    {
        Dispose();
    }
    
    public void Dispose()
    {
        if (!disposed)
        {
            detector?.Dispose();
            StopAllCoroutines();
            
            // Unsubscribe from events
            AprilTagPermissionsManager.OnAllPermissionsGranted -= OnPermissionsReady;
            
            disposed = true;
        }
    }
}
```

### Efficient Update Loops
```csharp
void Update()
{
    // Early exit for performance
    if (!isInitialized || !AprilTagPermissionsManager.HasAllPermissions)
        return;
    
    // Limit processing frequency
    if (Time.time - lastUpdateTime < updateInterval)
        return;
    
    ProcessDetection();
    lastUpdateTime = Time.time;
}
```

## Documentation Standards

### XML Documentation for Public APIs
```csharp
/// <summary>
/// Configures the AprilTag detector with specified parameters
/// </summary>
/// <param name="tagFamily">The tag family to detect (Tag36h11 or TagStandard41h12)</param>
/// <param name="tagSize">Physical size of tags in meters</param>
/// <param name="decimation">Downscale factor for performance optimization</param>
/// <returns>True if configuration was successful</returns>
public bool ConfigureDetector(TagFamily tagFamily, float tagSize, int decimation)
{
    // Implementation
}
```

### Code Comments
```csharp
void ProcessImage()
{
    // Get camera texture pixels for processing
    var pixels = webCamTexture.GetPixels32();
    
    // Apply decimation to reduce processing load
    int step = GetCurrentDecimation();
    
    // Process every Nth pixel based on decimation
    for (int y = 0; y < webCamTexture.height; y += step)
    {
        for (int x = 0; x < webCamTexture.width; x += step)
        {
            ProcessPixel(pixels[y * webCamTexture.width + x], x, y);
        }
    }
}
```

## Testing and Validation

### Input Validation
```csharp
public void SetTagSize(float size)
{
    if (size <= 0)
    {
        Debug.LogError("Tag size must be positive");
        return;
    }
    
    if (size > 10f)
    {
        Debug.LogWarning("Tag size seems unusually large - verify this is correct");
    }
    
    tagSizeMeters = size;
}
```

### Defensive Programming
```csharp
void OnTagDetected(int tagId, Vector3 position, Quaternion rotation)
{
    // Validate inputs
    if (tagId < 0)
    {
        Debug.LogError($"Invalid tag ID: {tagId}");
        return;
    }
    
    if (float.IsNaN(position.x) || float.IsNaN(position.y) || float.IsNaN(position.z))
    {
        Debug.LogError($"Invalid position detected for tag {tagId}");
        return;
    }
    
    // Proceed with processing
    HandleValidTagDetection(tagId, position, rotation);
}
```

## Platform-Specific Code

### Conditional Compilation
```csharp
void CheckPermissions()
{
    #if UNITY_EDITOR
        // Editor-specific behavior
        OnAllPermissionsGranted?.Invoke();
    #elif UNITY_ANDROID
        // Android/Quest-specific behavior
        CheckAndroidPermissions();
    #else
        // Other platforms
        OnAllPermissionsGranted?.Invoke();
    #endif
}
```

### Platform Abstraction
```csharp
public static class PlatformUtils
{
    public static bool IsQuestDevice()
    {
        #if UNITY_ANDROID && !UNITY_EDITOR
            return SystemInfo.deviceModel.Contains("Quest");
        #else
            return false;
        #endif
    }
    
    public static bool SupportsPassthrough()
    {
        return IsQuestDevice();
    }
}
```

## Configuration Management

### Serialized Configuration
```csharp
[System.Serializable]
public class AprilTagConfig
{
    [Header("Detection Settings")]
    public TagFamily tagFamily = TagFamily.Tag36h11;
    public float tagSizeMeters = 0.08f;
    public int decimation = 2;
    
    [Header("Performance")]
    public float maxDetectionsPerSecond = 15f;
    public bool enablePerformanceMonitoring = true;
    
    [Header("Debug")]
    public bool enableDebugLogs = false;
    public bool logOnlyDetections = true; // User preference
}
```

### Runtime Configuration Validation
```csharp
void ValidateConfiguration()
{
    if (config.decimation < 1 || config.decimation > 8)
    {
        Debug.LogWarning($"Invalid decimation value {config.decimation}, clamping to valid range");
        config.decimation = Mathf.Clamp(config.decimation, 1, 8);
    }
    
    if (config.tagSizeMeters <= 0)
    {
        Debug.LogError("Tag size must be positive");
        config.tagSizeMeters = 0.08f; // Default value
    }
}
```

## Best Practices Summary

1. **Follow Unity conventions** - Use proper MonoBehaviour patterns and Unity attributes
2. **Implement robust error handling** - Validate inputs and handle exceptions gracefully
3. **Use defensive programming** - Check for null and invalid values
4. **Document public APIs** - Provide XML documentation for public methods
5. **Handle platform differences** - Use conditional compilation appropriately
6. **Validate configuration** - Ensure settings are within valid ranges
7. **Follow memory management patterns** - Proper disposal and resource cleanup
8. **Optimize for performance** - Early exits and efficient update loops
9. **Respect user preferences** - Follow minimal debug output preference
10. **Never create .meta files** - Follow project-specific file management rules
11. **Quest headset focus** - All development should target Quest runtime, not editor debugging
12. **Avoid .unity file modifications** - Focus on code changes in C# files only
13. **Prioritize AprilTagSceneSetup.cs** - Primary configuration file for Quest deployment